# IO 同步 异步 阻塞 非阻塞

《UNIX网络编程：卷一》中定义了5种类UNIX下可用的I/O模型：
* 阻塞式I/O
* 非阻塞式I/O
* I/O复用（select，poll，epoll...）
* 信号驱动式I/O（SIGIO）
* 异步I/O（POSIX的aio_系列函数）

## 阻塞式I/O模型

默认情况下，所有套接字都是阻塞的。怎么理解？先理解这么个流程，一个输入操作通常包括两个不同阶段：

（1）等待数据准备好；

2）从内核向进程复制数据。

对于一个套接字上的输入操作，第一步通常涉及等待数据从网络中到达。当所有等待分组到达时，它被复制到内核中的某个缓冲区。第二步就是把数据从内核缓冲区复制到应用程序缓冲区。 好，下面我们以阻塞套接字的recvfrom的的调用图来说明阻塞
![](https://pic2.zhimg.com/e83d68da03da2e8c1568b4b4b630edfd_b.jpg)
标红的这部分过程就是阻塞，直到阻塞结束recvfrom才能返回。

## 非阻塞式I/O

这句话很重要：进程把一个套接字设置成非阻塞是在通知内核，当所请求的I/O操作非得把本进程投入睡眠才能完成时，不要把进程投入睡眠，而是返回一个错误。看看非阻塞的套接字的recvfrom操作如何进行
![](https://pic1.zhimg.com/4bc31cab27a9a732ab7d1ba9e674ed64_b.jpg)
可以看出recvfrom总是立即返回。

## I/O多路复用

虽然I/O多路复用的函数也是阻塞的，但是其与以上两种还是有不同的，I/O多路复用是阻塞在select，epoll这样的系统调用之上，而没有阻塞在真正的I/O系统调用如recvfrom之上。如图
![](https://pic1.zhimg.com/b1ec6a4f16844a27c175d5a6a94cd7f8_b.jpg)

## 信号驱动式I/O

用的很少
![](https://pic1.zhimg.com/6294fb7f7f5c22e39187a490c35ac6f0_b.jpg)

## 异步I/O

这类函数的工作机制是告知内核启动某个操作，并让内核在整个操作（包括将数据从内核拷贝到用户空间）完成后通知我们。如图：
![](https://pic2.zhimg.com/5819fd0fdff2bd4fdc9652291aca1831_b.jpg)
注意红线标记处说明在调用时就可以立马返回，等函数操作完成会通知我们。

再看POSIX对这两个术语的定义：

同步I/O操作：导致请求进程阻塞，直到I/O操作完成；

异步I/O操作：不导致请求进程阻塞。

好，下面我用我的语言来总结一下阻塞，非阻塞，同步，异步阻塞

非阻塞：进程/线程要访问的数据是否就绪，进程/线程是否需要等待；

同步，异步：访问数据的方式，同步需要主动读写数据，在读写数据的过程中还是会阻塞；异步只需要I/O操作完成的通知，并不主动读写数据，由操作系统内核完成数据的读写。


